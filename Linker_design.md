Linker Design Document
Author: Rashmitha
Module: 3 (Linker Core Logic & Design)
Date: September 6, 2025
Cited Source: MIPS_Assembler_Specification Document.pdf


1. High-Level Overview 
The linker is a command-line tool that is the second stage of our toolchain. Its primary role is to combine one or more relocatable object files (.o), which are produced by the assembler, into a single, fully-resolved executable file (.vm).

The linker's core responsibilities are:

Symbol Resolution: To map every symbol reference to a single, unique definition. It will report errors for undefined or duplicate global symbols.

Relocation: To "patch" the machine code by replacing placeholder addresses with the final, absolute memory addresses of functions and data.

Section Merging: To combine the code (.text) and data (.data) sections from all input object files into single, contiguous sections in the final executable.

2. File Formats 
The linker consumes .o files and produces a .vm file.

A. Input: Relocatable Object File (.o) Format
The linker must be able to parse the binary .o file generated by our assembler. The structure is as follows:

Section	Size (bytes)	Description
Header	20 bytes	Contains metadata about the file.
Magic Number	4	0x5354414F ("STAO") to identify it as a "STAk Object" file.
Code Section Size	4	Size of the code section in bytes.
Data Section Size	4	Size of the data section in bytes.
Symbol Table Size	4	Size of the symbol table section in bytes.
Relocation Table Size	4	Size of the relocation table section in bytes.
Code Section	Variable	The raw, un-relocated bytecode from the .text segment.
Data Section	Variable	The raw data from the .data segment.
Symbol Table Section	Variable	A list of all symbols defined and used in the file.
Relocation Table	Variable	A list of all locations in the code that need patching by the linker.

Export to Sheets
B. Output: Executable File (.vm) Format
The final output is a simple, loadable format for the Virtual Machine.

Section	Size (bytes)	Description
Header	16 bytes	Contains metadata needed by the VM to run the program.
Magic Number	4	0x5354414B ("STAK") to identify it as a runnable file.
Entry Point Address	4	The absolute address of the main function (or other entry point).
Code Section Size	4	The total size of the final, merged code section.
Data Section Size	4	The total size of the final, merged data section.
Code Section	Variable	The final, fully-resolved and patched bytecode.
Data Section	Variable	The final, combined static data.

Export to Sheets

3. Core Linking Algorithm 
The linker will execute the following steps in a strict sequence:

Parse Command-Line Arguments:

The linker will be invoked like: linker main.o math.o -o program.vm.

It will parse this to get a list of input .o files and one output .vm file name.

Read and Parse Object Files:

For each input .o file, the linker will read its contents into memory.

It will parse the binary data into the C++ ParsedObjectFile structure defined below, validating the magic number and section sizes.

Merge Sections & Build Global Symbol Table (Symbol Resolution):

Initialize a current_code_offset = 0 and current_data_offset = 0.

Create a single Global Symbol Table (e.g., std::map<std::string, FinalSymbol>).

Iterate through each ParsedObjectFile:

Iterate through its symbol_table:

Calculate the symbol's final absolute address:

If it's a TEXT symbol: final_address = current_code_offset + symbol.address.

If it's a DATA symbol: final_address = total_code_size + current_data_offset + symbol.address.

If the symbol is GLOBAL:

Check if it already exists in the Global Symbol Table. If so, throw a "duplicate symbol definition" error.

Add it to the Global Symbol Table with its final address.

If the symbol is LOCAL, we can ignore it for the global table, as it won't be referenced by other files.

Update the offsets for the next file: current_code_offset += file.code_section.size() and current_data_offset += file.data_section.size().

Perform Relocation:
Create two large byte vectors: final_code_section and final_data_section.

Initialize current_code_offset = 0 for tracking the base of the current file being processed.

Iterate through each ParsedObjectFile again:

Append its code_section to the final_code_section.

Iterate through its relocation_table:

For each RelocationEntry, look up its target_symbol in the Global Symbol Table. If not found, throw an "undefined symbol" error.

Get the final_address from the Global Symbol Table.

The location to patch in the final code is patch_location = current_code_offset + reloc_entry.offset.

Write the 4 bytes of final_address into final_code_section at the patch_location.

Update current_code_offset for the next file.

Write Executable (.vm) File:

Open the output file for binary writing.

Write the .vm header: Magic Number, the final address of the main symbol (looked up from the Global Symbol Table), the total code size, and the total data size.

Write the final_code_section.

Append the merged data_section from all files.

Close the file and report success.

4. Linker Data Structures (C++) 
These are the proposed C++ structures for the new linker program. They are designed to hold the parsed data from .o files in an organized way.

#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <cstdint>
#include <fstream>

// Represents a symbol as defined in the .o file's symbol table.
// This matches the structure Kowshik's emitter produces.
struct ObjectFileSymbol {
    enum class Type { TEXT, DATA };
    enum class Binding { LOCAL, GLOBAL };

    std::string name;
    Type type;
    Binding binding;
    uint32_t address; // Address is relative to the start of its section in the .o file
};

// Represents a relocation entry from the .o file.
struct RelocationEntry {
    uint32_t offset; // Offset within the code section of THIS file to patch.
    std::string target_symbol;
};

// A complete in-memory representation of a single parsed .o file.
class ParsedObjectFile {
public:
    std::vector<uint8_t> code_section;
    std::vector<uint8_t> data_section;
    std::vector<ObjectFileSymbol> symbol_table;
    std::vector<RelocationEntry> relocation_table;

    // A static factory method to load and parse an object file from disk.
    // This will be implemented by Nischith and Kowshik in Module 3/4.
    static ParsedObjectFile from_file(const std::string& filepath) {
        // Logic to open the file, read the header, and parse
        // each section into the data members will go here.
        // Throws std::runtime_error on failure.
        ParsedObjectFile obj;
        // ... parsing logic ...
        return obj;
    }
};

// Represents a symbol in the final Global Symbol Table after resolution.
struct FinalSymbol {
    std::string name;
    uint32_t final_address;
    bool is_defined = false; // To track if we have found its definition.
};